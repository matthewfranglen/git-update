#!/bin/bash

# This will update all of the branches which track remotes in the current
# repository. This will restore HEAD to the original location after that has
# completed.

# If an error occurs then the error will be prominently displayed and HEAD will
# be returned to the original location.

# This supports HEAD being on a branch or in a detached state.

# Just like Your MUM </dean>
# This tests to see if there are changes in the working tree or index that have
# not been committed. Since this will be switching branches a lot, it is
# undesirable to proceed if the current work could be lost.
# This will return a true status code if the tree is dirty.
is_dirty () {
    # First check for staged files, then check for unstaged files, then check
    # for files that have never been committed.
    # See: http://stackoverflow.com/a/5151886
    ! git diff-index --cached --quiet --ignore-submodules HEAD ||
        ! git diff-files --quiet --ignore-submodules ||
            [ -n "$(git ls-files --others --exclude-standard)" ]
}

# This will issue the current location to STDOUT. Capture it and pass it to
# restore_location once the update is complete. If the current HEAD is not on a
# branch tip then this will return the sha of the commit, unfortunately that
# will result in a detached head (but that should be no change from the current
# state).
get_location () {
    # See http://stackoverflow.com/a/4535867
    sha=$(git log --pretty="%H" -n 1)
    for branch in $(git branch --contains $sha | sed -e 's/\*//')
    do
        if [ "$(git rev-list -n 1 $branch)" = "$sha" ]
        then
            echo $branch
            return
        fi
    done
    echo $sha
}

# This takes a SHA or branch name and will move to that location.
restore_location () {
    git checkout "$1"
}

# This provides a list of the branches which track remotes.
list_branches () {
    # git version >= 1.7.0 can use
    # git rev-parse --symbolic-full-name my-branch@{upstream}
    # which will then display the full name of the remote branch when
    # successfully completed (check status). However I am not comfortable
    # relying on such a recent version, as plenty of dists use older versions.
    # Thus the command just checks the config for the remote section (which
    # itself just reads .git/config)

    # If you like functional zsh, then these commands are *ideal* for filtering.

    for branch in $(git branch)
    do
        git config branch.$branch.remote >/dev/null && echo $branch
    done
}

# This takes a branch name. This will check that branch out and then update it.
# The return status of this is the success of the pull. This will not rebase or
# merge, only updates which resolve as fast-forwards will be accepted.
update_branch () {
    git checkout $1 && git pull
}

# Updates all branches, stopping at the first one that fails.
update_branches () {
    for branch in $(list_branches)
    do
        update_branch "$branch"
        [ $? -ne 0 ] && return $?
    done
}

if is_dirty
then
    echo "Your index contains unstaged, uncommitted or new files" >&2
    exit 1
fi
original_location=$(get_location)

update_branches
status=$?

restore_location "$original_location"
exit $status

# vim: set ai et sw=4 syntax=sh :
